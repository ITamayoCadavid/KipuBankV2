// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/security/ReentrancyGuard.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/token/ERC20/IERC20.sol";
import "https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v4.9.3/contracts/token/ERC20/utils/SafeERC20.sol";

interface IUniswapV2RouterMock {
    function swapExactETHForTokens(uint256 amountOutMin, address tokenOut, address to) external payable returns (uint256);
    function swapExactTokensForETH(uint256 amountIn, uint256 amountOutMin, address tokenIn, address to) external returns (uint256);
    function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address tokenIn, address tokenOut, address to) external returns (uint256);
}

contract KipuBankV3 is ReentrancyGuard {
    using SafeERC20 for IERC20;

    // --- Config ---
    address public owner;
    IERC20 public usdc;
    IUniswapV2RouterMock public router;

    // --- Límites ---
    uint256 public bankCap;     // máximo total permitido
    uint256 public userCap;     // máximo por usuario
    uint256 public minDeposit;  // depósito mínimo

    // --- Balances ---
    mapping(address => uint256) public balancesUSDC;

    // --- Totales separados ---
    uint256 public totalDepositedUSDC;
    uint256 public totalDepositedETH;
    uint256 public totalDepositedToken;
    uint256 public totalWithdrawnUSDC;
    uint256 public totalWithdrawnETH;
    uint256 public totalWithdrawnToken;

    // --- Eventos ---
    event DepositUSDC(address indexed user, uint256 amount);
    event DepositETHConverted(address indexed user, uint256 ethAmount, uint256 usdcReceived);
    event DepositTokenConverted(address indexed user, address token, uint256 tokenAmount, uint256 usdcReceived);
    event WithdrawUSDC(address indexed user, uint256 amount);
    event WithdrawETH(address indexed user, uint256 usdcSpent, uint256 ethOut);
    event WithdrawToken(address indexed user, uint256 usdcSpent, address token, uint256 tokenOut);
    event SwapETHToToken(address indexed user, uint256 ethIn, address tokenOut, uint256 tokenReceived);
    event TotalsUpdated(
        uint256 totalDepositedUSDC,
        uint256 totalDepositedETH,
        uint256 totalDepositedToken,
        uint256 totalWithdrawnUSDC,
        uint256 totalWithdrawnETH,
        uint256 totalWithdrawnToken
    );

    // --- Modifiers ---
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    constructor(address _router, address _usdc) {
        owner = msg.sender;
        router = IUniswapV2RouterMock(_router);
        usdc = IERC20(_usdc);

        // valores por defecto
        bankCap = 1_000_000 * 10**6; // 1M USDC
        userCap = 50_000 * 10**6;    // 50k USDC
        minDeposit = 1 * 10**6;      // 1 USDC
    }

    // --- Admin ---
    function setRouter(address _router) external onlyOwner {
        router = IUniswapV2RouterMock(_router);
    }

    function setUSDC(address _usdc) external onlyOwner {
        usdc = IERC20(_usdc);
    }

    function setBankCap(uint256 _cap) external onlyOwner {
        bankCap = _cap;
    }

    function setUserCap(uint256 _cap) external onlyOwner {
        userCap = _cap;
    }

    function setMinDeposit(uint256 _min) external onlyOwner {
        minDeposit = _min;
    }

    // --- Depósitos ---

    /// @notice Deposita USDC directo al banco
    function depositUSDC(uint256 amount) external nonReentrant {
        require(amount >= minDeposit, "Below min deposit");
        require(totalUSDCInBank() + amount <= bankCap, "Bank cap reached");
        require(balancesUSDC[msg.sender] + amount <= userCap, "User cap reached");

        usdc.safeTransferFrom(msg.sender, address(this), amount);
        balancesUSDC[msg.sender] += amount;
        totalDepositedUSDC += amount;

        emit DepositUSDC(msg.sender, amount);
        _emitTotals();
    }

    /// @notice Deposita ETH y lo convierte a USDC
    function depositETHAndConvertToUSDC(uint256 amountOutMin) external payable nonReentrant {
        require(msg.value > 0, "No ETH sent");
        require(msg.value >= minDeposit, "Below min deposit");
        require(totalUSDCInBank() <= bankCap, "Bank cap reached");

        uint256 usdcReceived = router.swapExactETHForTokens{value: msg.value}(amountOutMin, address(usdc), address(this));
        balancesUSDC[msg.sender] += usdcReceived;
        totalDepositedETH += msg.value;

        emit DepositETHConverted(msg.sender, msg.value, usdcReceived);
        _emitTotals();
    }

    /// @notice Deposita otro token y lo convierte a USDC
    function depositTokenAndConvertToUSDC(address tokenIn, uint256 amount, uint256 amountOutMin) external nonReentrant {
        require(amount > 0, "Invalid amount");
        require(amount >= minDeposit, "Below min deposit");

        IERC20(tokenIn).safeTransferFrom(msg.sender, address(this), amount);
        IERC20(tokenIn).safeApprove(address(router), amount);

        uint256 usdcReceived = router.swapExactTokensForTokens(amount, amountOutMin, tokenIn, address(usdc), address(this));
        balancesUSDC[msg.sender] += usdcReceived;
        totalDepositedToken += amount;

        emit DepositTokenConverted(msg.sender, tokenIn, amount, usdcReceived);
        _emitTotals();
    }

    // --- Retiros ---

    function withdrawUSDC(uint256 amount) external nonReentrant {
        require(balancesUSDC[msg.sender] >= amount, "Insufficient balance");
        balancesUSDC[msg.sender] -= amount;
        totalWithdrawnUSDC += amount;

        usdc.safeTransfer(msg.sender, amount);
        emit WithdrawUSDC(msg.sender, amount);
        _emitTotals();
    }

    /// @notice Convierte USDC a ETH y lo envía al usuario
    function swapUSDCToETHAndWithdraw(uint256 amountUSDC, uint256 amountOutMin) external nonReentrant {
        require(balancesUSDC[msg.sender] >= amountUSDC, "Insufficient balance");

        balancesUSDC[msg.sender] -= amountUSDC;
        usdc.safeApprove(address(router), amountUSDC);
        uint256 ethOut = router.swapExactTokensForETH(amountUSDC, amountOutMin, address(usdc), msg.sender);

        totalWithdrawnETH += ethOut;
        emit WithdrawETH(msg.sender, amountUSDC, ethOut);
        _emitTotals();
    }

    /// @notice Convierte USDC a otro token y lo envía al usuario
    function swapUSDCToTokenAndWithdraw(uint256 amountUSDC, address tokenOut, uint256 amountOutMin) external nonReentrant {
        require(balancesUSDC[msg.sender] >= amountUSDC, "Insufficient balance");

        balancesUSDC[msg.sender] -= amountUSDC;
        usdc.safeApprove(address(router), amountUSDC);

        uint256 tokenOutAmt = router.swapExactTokensForTokens(amountUSDC, amountOutMin, address(usdc), tokenOut, msg.sender);
        totalWithdrawnToken += tokenOutAmt;

        emit WithdrawToken(msg.sender, amountUSDC, tokenOut, tokenOutAmt);
        _emitTotals();
    }

    /// @notice Swap directo ETH -> Token (fuera del balance del banco)
    function swapETHToTokenDirect(address tokenOut, uint256 amountOutMin) external payable nonReentrant {
        require(msg.value > 0, "No ETH sent");
        uint256 tokenReceived = router.swapExactETHForTokens{value: msg.value}(amountOutMin, tokenOut, msg.sender);

        emit SwapETHToToken(msg.sender, msg.value, tokenOut, tokenReceived);
    }

    // --- Consultas ---
    function totalUSDCInBank() public view returns (uint256) {
        return usdc.balanceOf(address(this));
    }

    function getTotals()
        external
        view
        returns (
            uint256 _totalDepositedUSDC,
            uint256 _totalDepositedETH,
            uint256 _totalDepositedToken,
            uint256 _totalWithdrawnUSDC,
            uint256 _totalWithdrawnETH,
            uint256 _totalWithdrawnToken
        )
    {
        return (
            totalDepositedUSDC,
            totalDepositedETH,
            totalDepositedToken,
            totalWithdrawnUSDC,
            totalWithdrawnETH,
            totalWithdrawnToken
        );
    }

    // --- Interno ---
    function _emitTotals() internal {
        emit TotalsUpdated(
            totalDepositedUSDC,
            totalDepositedETH,
            totalDepositedToken,
            totalWithdrawnUSDC,
            totalWithdrawnETH,
            totalWithdrawnToken
        );
    }

    // --- Fallback ---
    receive() external payable {}
}


// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC20 {
    function transfer(address to, uint256 amt) external returns (bool);
    function transferFrom(address from, address to, uint256 amt) external returns (bool);
    function decimals() external view returns (uint8);
    function mint(address to, uint256 amt) external;
}

/// @title Mock Uniswap V2 Router para pruebas
contract MockUniswapV2Router {
    address public owner;

    uint256 public ethToUSDCRate; // USDC por 1 ETH
    mapping(address => uint256) public tokenToUSDCRate; // token -> USDC
    mapping(address => uint256) public tokenToETHRate;  // token -> ETH

    constructor() {
        owner = msg.sender;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "not owner");
        _;
    }

    // --- Configuración de tasas ---
    function setEthToUSDCRate(uint256 rate) external onlyOwner {
        ethToUSDCRate = rate;
    }

    function setTokenToUSDCRate(address token, uint256 rate) external onlyOwner {
        tokenToUSDCRate[token] = rate;
    }

    function setTokenToETHRate(address token, uint256 rate) external onlyOwner {
        tokenToETHRate[token] = rate;
    }

    // --- Swaps simulados ---
    // ETH -> Token
    function swapExactETHForTokens(
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external payable returns (uint[] memory amounts) {
        require(msg.value > 0, "no ETH");
        require(ethToUSDCRate > 0, "rate not set");

        uint amountOut = (msg.value * ethToUSDCRate) / 1 ether;
        IERC20(path[path.length - 1]).mint(to, amountOut);

        amounts = new uint ;
        amounts[0] = msg.value;
        amounts[1] = amountOut;
    }

    // Token -> ETH
    function swapExactTokensForETH(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts) {
        address token = path[0];
        require(tokenToETHRate[token] > 0, "rate not set");

        IERC20(token).transferFrom(msg.sender, address(this), amountIn);

        uint amountOut = (amountIn * tokenToETHRate[token]) / (10 ** IERC20(token).decimals());
        (bool ok, ) = to.call{value: amountOut}("");
        require(ok, "ETH send failed");

        amounts = new uint ;
        amounts[0] = amountIn;
        amounts[1] = amountOut;
    }

    // Token -> Token (ej. cualquier token -> USDC)
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts) {
        address tokenIn = path[0];
        address tokenOut = path[path.length - 1];
        require(tokenToUSDCRate[tokenIn] > 0, "rate not set");

        IERC20(tokenIn).transferFrom(msg.sender, address(this), amountIn);
        uint amountOut = (amountIn * tokenToUSDCRate[tokenIn]) / (10 ** IERC20(tokenIn).decimals());
        IERC20(tokenOut).mint(to, amountOut);

        amounts = new uint ;
        amounts[0] = amountIn;
        amounts[1] = amountOut;
    }

    receive() external payable {}
}



***************
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// ---- IMPORTS ----
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

// ---- INTERFAZ UNISWAP V2 MOCK ----
interface IUniswapV2Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

// ---- CONTRATO PRINCIPAL ----
contract KipuBankV3 is Ownable, ReentrancyGuard {
    IUniswapV2Router public immutable router;
    address public immutable USDC; // dirección del USDC

    uint256 public immutable withdrawLimit;  
    uint256 public immutable bankCap;       

    uint256 public totalETHDeposits;
    uint256 public totalUSDCDeposits;

    mapping(address => uint256) public userETHBalances;
    mapping(address => uint256) public userUSDCBalances;

    // ---- EVENTOS ----
    event DepositETH(address indexed user, uint256 amount);
    event DepositUSDC(address indexed user, uint256 amount);
    event WithdrawETH(address indexed user, uint256 amount);
    event WithdrawUSDC(address indexed user, uint256 amount);

    // ---- CONSTRUCTOR ----
    constructor(
        address _router,
        address _usdc,
        uint256 _withdrawLimit,
        uint256 _bankCap
    ) Ownable(msg.sender) {
        router = IUniswapV2Router(_router);
        USDC = _usdc;
        withdrawLimit = _withdrawLimit;
        bankCap = _bankCap;
    }

    // ---- DEPÓSITO DE ETH ----
    function depositETH() external payable nonReentrant {
        require(msg.value > 0, "Monto invalido");
        require(totalETHDeposits + msg.value <= bankCap, "Capacidad del banco alcanzada");

        userETHBalances[msg.sender] += msg.value;
        totalETHDeposits += msg.value;

        emit DepositETH(msg.sender, msg.value);
    }

    // ---- DEPÓSITO DE TOKENS (USDC o swap a USDC) ----
    function depositToken(address token, uint256 amount) external nonReentrant {
        require(amount > 0, "Monto invalido");

        if(token == USDC) {
            // depósito directo de USDC
            require(totalUSDCDeposits + amount <= bankCap, "Capacidad del banco alcanzada");

            IERC20(token).transferFrom(msg.sender, address(this), amount);
            userUSDCBalances[msg.sender] += amount;
            totalUSDCDeposits += amount;

            emit DepositUSDC(msg.sender, amount);
        } else {
            // swap a USDC
            IERC20(token).transferFrom(msg.sender, address(this), amount);
            uint256 usdcReceived = swapTokenToUSDC(token, amount);

            require(totalUSDCDeposits + usdcReceived <= bankCap, "Capacidad del banco alcanzada");

            userUSDCBalances[msg.sender] += usdcReceived;
            totalUSDCDeposits += usdcReceived;

            emit DepositUSDC(msg.sender, usdcReceived);
        }
    }

    // ---- FUNCION INTERNA DE SWAP ----
    function swapTokenToUSDC(address token, uint256 amount) internal returns (uint256) {
        IERC20(token).approve(address(router), amount);

        // Declaración correcta del array de direcciones en memoria
     // Correct declaration of the path array
    address[] memory path = new address[](2);
    path[0] = token;
    path[1] = USDC;

    uint[] memory amounts = router.swapExactTokensForTokens(
        amount,
        0, // accepts any minimum amount (not recommended for production)
        path,
        address(this),
        block.timestamp
    );

    return amounts[1];
}

    // ---- RETIRO ETH ----
    function withdrawETH(uint256 amount) external nonReentrant {
        require(amount <= withdrawLimit, "Excede limite por transaccion");
        require(userETHBalances[msg.sender] >= amount, "Saldo insuficiente");

        userETHBalances[msg.sender] -= amount;
        totalETHDeposits -= amount;

        (bool sent, ) = msg.sender.call{value: amount}("");
        require(sent, "Fallo transferencia ETH");

        emit WithdrawETH(msg.sender, amount);
    }

    // ---- RETIRO USDC ----
    function withdrawUSDC(uint256 amount) external nonReentrant {
        require(amount <= withdrawLimit, "Excede limite por transaccion");
        require(userUSDCBalances[msg.sender] >= amount, "Saldo insuficiente");

        userUSDCBalances[msg.sender] -= amount;
        totalUSDCDeposits -= amount;

        IERC20(USDC).transfer(msg.sender, amount);

        emit WithdrawUSDC(msg.sender, amount);
    }

    // ---- CONSULTA DE SALDOS ----
    function getBalanceETH(address user) external view returns (uint256) {
        return userETHBalances[user];
    }

    function getBalanceUSDC(address user) external view returns (uint256) {
        return userUSDCBalances[user];
    }
}


